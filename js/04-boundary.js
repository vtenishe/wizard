/* =============================================================================
   FILE:    js/04-boundary.js
   PROJECT: AMPS CCMC Submission Interface  v3
   PURPOSE: Step 4 — Simulation domain boundary configuration and live SVG
            diagram renderer for both BOX and Shue (1998) geometries.

   ╔═══════════════════════════════════════════════════════════════════════╗
   ║                        ARCHITECTURE OVERVIEW                        ║
   ╠═══════════════════════════════════════════════════════════════════════╣
   ║                                                                     ║
   ║  The simulation boundary defines where AMPS injects test particles ║
   ║  and where it stops tracing them.  Two geometries are supported:   ║
   ║                                                                     ║
   ║  BOX  — Axis-aligned rectangular cuboid in GSM coordinates.        ║
   ║         Six face parameters: Xmax, Xmin, Ymax, Ymin, Zmax, Zmin   ║
   ║         Simple, predictable.  Good for GCR and parameter sweeps.   ║
   ║         Keyword: BOUNDARY_TYPE = BOX                               ║
   ║                                                                     ║
   ║  SHUE — Shue et al. (1998) empirical magnetopause surface.        ║
   ║         r(θ) = r₀ · (2 / (1 + cos θ))^α                          ║
   ║         r₀ and α respond to Pdyn and IMF Bz automatically,        ║
   ║         compressing during storms.  Reduces wasted traces ~20–30%. ║
   ║         Keyword: BOUNDARY_TYPE = SHUE                              ║
   ║                                                                     ║
   ╠═══════════════════════════════════════════════════════════════════════╣
   ║  SHUE AUTO-COMPUTE FORMULAS  (Shue et al. 1998)                   ║
   ║                                                                     ║
   ║  r₀ = (11.4 + 0.013·Bz) · Pdyn^(−1/6.6)         [RE]            ║
   ║  α  = (0.58 − 0.007·Bz) · (1 + 0.024·ln(Pdyn))   []            ║
   ║                                                                     ║
   ║  Bz, Pdyn are read from S (set in Step 3 B-field config).        ║
   ║  Manual overrides: user can set r₀ and α directly.                ║
   ║                                                                     ║
   ╠═══════════════════════════════════════════════════════════════════════╣
   ║  STATE PROPERTIES READ/WRITTEN  (from S in 01-state.js)           ║
   ║                                                                     ║
   ║  S.boundaryType   string  'BOX' | 'SHUE'                          ║
   ║  S.shueMode       string  'auto' | 'manual'                       ║
   ║  S.boxXmax..Zmin  float   BOX face positions [RE, GSM]            ║
   ║  S.boxRinner      float   BOX inner loss sphere [RE]              ║
   ║  S.shueR0         float   Shue manual r₀ [RE]  (null = auto)     ║
   ║  S.shueAlpha      float   Shue manual α []     (null = auto)     ║
   ║  S.xtail          float   Nightside tail-cap cut [RE]             ║
   ║  S.shueRinner     float   Shue inner boundary [RE]                ║
   ║  S.dst            float   (read) Dst index [nT]                   ║
   ║  S.pdyn           float   (read) solar wind Pdyn [nPa]            ║
   ║  S.bz             float   (read) IMF Bz [nT]                     ║
   ║                                                                     ║
   ╠═══════════════════════════════════════════════════════════════════════╣
   ║  AMPS_PARAM.in KEYWORDS  (generated by 08-review.js)              ║
   ║                                                                     ║
   ║  #DOMAIN_BOUNDARY                                                  ║
   ║  BOUNDARY_TYPE = BOX | SHUE                                        ║
   ║  DOMAIN_XMAX / XMIN / YMAX / YMIN / ZMAX / ZMIN  (BOX mode)     ║
   ║  R_INNER          = <float> RE                                     ║
   ║  SHUE_R0          = AUTO | <float>  (SHUE mode)                   ║
   ║  SHUE_ALPHA       = AUTO | <float>  (SHUE mode)                   ║
   ║  SHUE_XTAIL       = <float> RE      (SHUE mode)                   ║
   ║                                                                     ║
   ╠═══════════════════════════════════════════════════════════════════════╣
   ║  SVG DIAGRAM  (#bnd-svg, viewBox 400×320)                         ║
   ║                                                                     ║
   ║  Coordinate system: origin at (CX=200, CY=160)                    ║
   ║  Scale: SC = 5 px/RE.  +X_GSM (sun) → right; +Z_GSM → up.       ║
   ║  BOX:  rectangle + dimension labels + R_inner circle              ║
   ║  SHUE: 181-point path + tail-cap + r₀/flank annotations          ║
   ║  Grid: drawn once by drawSvgGrid() during init                    ║
   ║                                                                     ║
   ╠═══════════════════════════════════════════════════════════════════════╣
   ║  FUNCTION INDEX                                                    ║
   ║                                                                     ║
   ║  §1 INTERNAL HELPERS (pure, no DOM)                                ║
   ║     shueCalc()         → {r0, alpha} from S.dst/pdyn/bz           ║
   ║     getShue()          → active {r0, alpha} (auto or manual)      ║
   ║     shueR(r0, al, deg) → radial distance at angle deg             ║
   ║                                                                     ║
   ║  §2 PUBLIC API                                                     ║
   ║     bndSet(type)       — switch BOX / SHUE                        ║
   ║     shueMode(m)        — toggle auto / manual                     ║
   ║     bndBoxUpdate()     — read BOX inputs → SVG + validate         ║
   ║     bndShueUpdate()    — compute Shue → SVG + validate            ║
   ║     drawSvgGrid(svgId) — draw background grid (called once)       ║
   ║                                                                     ║
   ║  §3 COMPATIBILITY SHIMS                                            ║
   ║     setBoundary(which) — legacy alias for bndSet()                 ║
   ║     setShueMode(b,m)   — legacy alias for shueMode()              ║
   ║                                                                     ║
   ╚═══════════════════════════════════════════════════════════════════════╝

   COORDINATE HELPERS (from 01-state.js — do NOT redeclare):
     gx(re) → SVG pixel X     gz(re) → SVG pixel Y     cl(v,lo,hi) → clamp

   DEPENDS ON: 01-state.js (S, $, set, CX, CY, SC, gx, gz, cl),
               updateSidebar() from 02-wizard.js
   LAST UPDATED: 2026-03-01
============================================================================= */


/* ═══════════════════════════════════════════════════════════════════════════
   §1  INTERNAL HELPERS — pure geometry (no DOM access)
   ═══════════════════════════════════════════════════════════════════════════ */

/**
 * Compute Shue (1998) parameters from current solar-wind state.
 *
 * Uses the Shue et al. (1998) empirical formulas:
 *   r₀ = (11.4 + 0.013·Bz) · Pdyn^(−1/6.6)
 *   α  = (0.58 − 0.007·Bz) · (1 + 0.024·ln(Pdyn))
 *
 * Results are clamped to physically reasonable ranges:
 *   r₀ ∈ [4, 15] RE     (prevents unphysical extremes)
 *   α  ∈ [0.3, 0.9]     (prevents negative or flat surfaces)
 *
 * @returns {{ r0: number, alpha: number }}
 */
function shueCalc() {
  const bz = S.bz;
  const pd = Math.max(0.1, S.pdyn);  // guard: Pdyn must be positive for log/power

  const r0    = Math.max(4, Math.min(15, (11.4 + 0.013 * bz) * Math.pow(pd, -1 / 6.6)));
  const alpha = Math.max(0.3, Math.min(0.9, (0.58 - 0.007 * bz) * (1 + 0.024 * Math.log(pd))));

  return { r0, alpha: alpha };
}

/**
 * Get the active Shue parameters — either auto-computed or manually set.
 *
 * In MANUAL mode, returns user-supplied S.shueR0 and S.shueAlpha if both
 * are non-null.  Otherwise, falls back to auto-computed values from shueCalc().
 *
 * @returns {{ r0: number, alpha: number }}
 */
function getShue() {
  if (S.shueMode === 'manual' && S.shueR0 && S.shueAlpha) {
    return { r0: S.shueR0, alpha: S.shueAlpha };
  }
  return shueCalc();
}

/**
 * Compute the Shue radial distance at a given polar angle.
 *
 * Formula: r(θ) = r₀ · (2 / (1 + cos θ))^α
 *
 * At θ = 0° (subsolar point): r = r₀
 * At θ = 90° (terminator):    r = r₀ · 2^α
 * At θ → 180° (tail):         r → ∞ (capped at Infinity)
 *
 * @param {number} r0  — subsolar standoff distance [RE]
 * @param {number} al  — flaring exponent []
 * @param {number} deg — polar angle from sun–Earth line [degrees]
 * @returns {number}     radial distance [RE] (may be Infinity near 180°)
 */
function shueR(r0, al, deg) {
  const th = deg * Math.PI / 180;
  const d  = 1 + Math.cos(th);
  return d < 1e-9 ? Infinity : r0 * Math.pow(2 / d, al);
}


/* ═══════════════════════════════════════════════════════════════════════════
   §2  PUBLIC API — UI handlers
   ═══════════════════════════════════════════════════════════════════════════ */

/**
 * Switch between BOX and SHUE boundary types.
 *
 * Flow:
 *   1. Write S.boundaryType
 *   2. Toggle card highlights (#bc-box, #bc-shue)
 *   3. Show/hide the matching parameter panel
 *   4. Trigger the appropriate update function (draws SVG + validates)
 *   5. Refresh sidebar
 *
 * @param {string} type — 'BOX' | 'SHUE'
 */
function bndSet(type) {
  S.boundaryType = type;

  /* Card highlights */
  $('bc-box')?.classList.toggle('sel', type === 'BOX');
  $('bc-shue')?.classList.toggle('sel', type === 'SHUE');

  /* Panel visibility */
  $('bnd-box-panel').style.display  = type === 'BOX'  ? 'block' : 'none';
  $('bnd-shue-panel').style.display = type === 'SHUE' ? 'block' : 'none';

  /* Draw the active boundary diagram */
  if (type === 'SHUE') bndShueUpdate();
  else                  bndBoxUpdate();

  updateSidebar();
}

/**
 * Toggle Shue parameter mode between AUTO and MANUAL.
 *
 * AUTO:   r₀ and α are computed from S.dst / S.pdyn / S.bz (Shue 1998 formulas).
 * MANUAL: user enters r₀ and α directly.
 *
 * NOTE: Two button-ID conventions exist across HTML variants:
 *   index.html / AMPS_Interface.html → 'shue-manual-btn'
 *   panel_boundary.html              → 'shue-man-btn'
 * We toggle both to stay compatible.
 *
 * @param {string} m — 'auto' | 'manual'
 */
function shueMode(m) {
  S.shueMode = m;

  /* Button highlights (support both ID conventions) */
  $('shue-auto-btn')?.classList.toggle('on', m === 'auto');
  $('shue-manual-btn')?.classList.toggle('on', m === 'manual');
  $('shue-man-btn')?.classList.toggle('on', m === 'manual');

  /* Show/hide manual input fields; dim auto display when overriding */
  $('shue-manual-fields').style.display = m === 'manual' ? 'block' : 'none';
  $('shue-auto-box').style.opacity      = m === 'manual' ? '0.5'   : '1';

  bndShueUpdate();
}


/* ───────────────────────────────────────────────────────────────────────────
   Compatibility shims — keep legacy HTML onclick handlers working.

   Historical context: index.html and AMPS_Interface.html diverged in their
   onclick handler names.  These shims bridge the gap so all variants work.
   DO NOT REMOVE unless all HTML files are updated to use bndSet/shueMode.
   ─────────────────────────────────────────────────────────────────────────── */

/** Legacy alias: setBoundary('box'|'shue') → bndSet('BOX'|'SHUE') */
window.setBoundary = window.setBoundary || function(which) {
  const w = String(which || '').toLowerCase();
  if (w === 'box')  return bndSet('BOX');
  if (w === 'shue') return bndSet('SHUE');
  return bndSet(which);
};

/** Legacy alias: setShueMode(this,'auto'|'manual') → shueMode('auto'|'manual') */
window.setShueMode = window.setShueMode || function(_btn, mode) {
  return shueMode(mode);
};


/* ═══════════════════════════════════════════════════════════════════════════
   §2a  BOX UPDATE — read inputs, draw rectangle SVG, validate, set keywords
   ═══════════════════════════════════════════════════════════════════════════ */

/**
 * Read BOX boundary inputs from DOM, update SVG, validate, and set keyword strips.
 *
 * Pipeline:
 *   1. Read 6 face positions + R_inner from #box-* inputs → S
 *   2. Draw the rectangle in SVG (#box-rect) + inner boundary circle (#inner-box)
 *   3. Position dimension labels (#box-lbl-xmax, etc.)
 *   4. Run validation checks (dayside reach, flank width, Z range, R_inner)
 *   5. Update keyword preview strips
 *
 * Called from oninput handlers on all BOX parameter inputs.
 */
function bndBoxUpdate() {
  /* ── 1. Read inputs → S ─────────────────────────────────────────────── */
  const v = k => parseFloat($(k)?.value) || 0;
  S.boxXmax = v('box-xmax');   S.boxXmin = v('box-xmin');
  S.boxYmax = v('box-ymax');   S.boxYmin = v('box-ymin');
  S.boxZmax = v('box-zmax');   S.boxZmin = v('box-zmin');
  S.boxRinner = v('box-rinner');

  /* ── 2. Draw rectangle in SVG ───────────────────────────────────────── */
  /* Convert GSM coordinates to SVG pixels, clamped to viewport */
  const rx = cl(gx(S.boxXmin), 5, 390);
  const ry = cl(gz(S.boxZmax), 5, 310);
  const rw = cl(gx(S.boxXmax), 5, 390) - rx;
  const rh = cl(gz(S.boxZmin), 5, 310) - ry;

  const rect = $('box-rect');
  if (rect) {
    rect.setAttribute('x', rx);
    rect.setAttribute('y', ry);
    rect.setAttribute('width',  Math.max(0, rw));
    rect.setAttribute('height', Math.max(0, rh));
  }

  /* Inner boundary circle (R_inner) */
  const ib = $('inner-box');
  if (ib) ib.setAttribute('r', S.boxRinner * SC);

  /* ── 3. Position dimension labels ───────────────────────────────────── */
  const sl = (id, t, x, y) => {
    const e = $(id);
    if (e) { e.setAttribute('x', x); e.setAttribute('y', y); e.textContent = t; }
  };
  sl('box-lbl-xmax', 'Xmax=' + S.boxXmax, cl(gx(S.boxXmax) + 2, 10, 360), CY + 14);
  sl('box-lbl-xmin', 'Xmin=' + S.boxXmin, cl(gx(S.boxXmin) - 34, 5, 300), CY + 14);
  sl('box-lbl-zmax', 'Zmax=' + S.boxZmax, CX + 4, cl(gz(S.boxZmax) - 3, 14, 306));
  sl('box-lbl-zmin', 'Zmin=' + S.boxZmin, CX + 4, cl(gz(S.boxZmin) + 11, 14, 306));

  /* ── 4. Validation checks ───────────────────────────────────────────── */
  const vi = (id, ok, okTxt, failTxt) => {
    const e = $(id);
    if (e) e.innerHTML = ok
      ? `<span class="v-ok">${okTxt}</span>`
      : `<span class="v-warn">${failTxt}</span>`;
  };
  vi('bv-xrange', S.boxXmax > 9,                                       '✓ Dayside OK',   '⚠ Xmax < 9 RE');
  vi('bv-yrange', S.boxYmax >= 15,                                     '✓ Flanks OK',    '⚠ Y < 15 RE');
  vi('bv-zrange', S.boxZmax > 12 && Math.abs(S.boxZmin) > 12,          '✓ Z range OK',   '⚠ |Z| < 12 RE');
  vi('bv-inner',  S.boxRinner >= 1.5 && S.boxRinner <= 3.5,            '✓ R_inner OK',   '⚠ Typical 1.5–3.5 RE');

  /* ── 5. Keyword preview strips ──────────────────────────────────────── */
  ['xmax', 'xmin', 'ymax', 'ymin', 'zmax', 'zmin', 'rinner'].forEach(k => {
    const e = $('kw-' + k);
    /* Property name: 'xmax' → S.boxXmax, 'rinner' → S.boxRinner */
    if (e) e.textContent = Number(S['box' + k.charAt(0).toUpperCase() + k.slice(1)]).toFixed(1);
  });
}


/* ═══════════════════════════════════════════════════════════════════════════
   §2b  SHUE UPDATE — compute r₀/α, draw curved SVG, validate, set keywords
   ═══════════════════════════════════════════════════════════════════════════ */

/**
 * Recompute Shue parameters, draw the magnetopause SVG path, validate,
 * and update keyword preview strips.
 *
 * Pipeline:
 *   1. Read auxiliary inputs (Xtail, R_inner, manual overrides) → S
 *   2. Compute r₀/α via getShue() (auto or manual)
 *   3. Update parameter display (r₀, α, X_sub, R_flank)
 *   4. Build SVG path: 181 points at 1° steps from θ=0° to θ=180°
 *   5. Draw tail-cap line, inner boundary circle
 *   6. Position r₀ and flank annotation arrows
 *   7. Update dynamic text readouts in SVG
 *   8. Run validation checks
 *   9. Update keyword preview strips
 *
 * Called from oninput handlers on Shue parameter inputs, and after
 * any Step 3 B-field parameter changes that affect S.dst / S.pdyn / S.bz.
 */
function bndShueUpdate() {
  /* ── 1. Read auxiliary inputs ────────────────────────────────────────── */
  const v = k => parseFloat($(k)?.value);
  S.xtail    = v('shue-xtail')  || S.xtail;
  S.shueRinner = v('shue-rinner') || S.shueRinner;

  /* In manual mode, read user-supplied r₀ and α (null = use auto) */
  if (S.shueMode === 'manual') {
    S.shueR0    = v('shue-r0-in')    || null;
    S.shueAlpha = v('shue-alpha-in') || null;
  }

  /* ── 2. Compute active parameters ───────────────────────────────────── */
  const { r0, alpha } = getShue();

  /* ── 3. Update parameter display ────────────────────────────────────── */
  const setText = (id, val) => { const e = $(id); if (e) e.textContent = val; };
  setText('shue-r0-val',     r0.toFixed(2));
  setText('shue-alpha-val',  alpha.toFixed(3));
  setText('shue-xsub-val',   r0.toFixed(2));      // X_sub = r₀ at θ=0°
  const rFlank = shueR(r0, alpha, 90);             // terminator distance
  setText('shue-rflank-val', isFinite(rFlank) ? rFlank.toFixed(1) : '—');

  /* ── 4. Build Shue SVG path (181 points, θ = 0° to 180°) ───────────── */
  const xtSvgX = cl(gx(S.xtail), 8, 390);         // tail-cap SVG X
  let upper = [], lower = [];

  for (let d = 0; d <= 180; d += 1) {
    const r = shueR(r0, alpha, d);
    if (!isFinite(r)) continue;

    /* Convert polar (r, θ) to GSM Cartesian */
    const th  = d * Math.PI / 180;
    const gx2 = r * Math.cos(th);   // GSM X
    const gz2 = r * Math.sin(th);   // GSM Z (upper half)

    /* Clip at tail boundary */
    if (gx2 < S.xtail) continue;

    /* Map to SVG pixels (clamped to viewport) */
    upper.push([cl(gx(gx2), 5, 390), cl(gz(gz2), 5, 310)]);    // northern hemisphere
    lower.unshift([cl(gx(gx2), 5, 390), cl(gz(-gz2), 5, 310)]); // southern (mirrored)
  }

  /* Assemble closed SVG path: upper arc → tail-cap → lower arc → close */
  if (upper.length > 1) {
    let path = `M ${upper[0][0]},${upper[0][1]}`;
    upper.forEach(([x, y]) => path += ` L ${x},${y}`);

    /* Connect upper arc to tail-cap bottom */
    const tailZ = shueR(r0, alpha, 179.9) * Math.sin(179.9 * Math.PI / 180);
    path += ` L ${xtSvgX},${cl(gz(-tailZ), 5, 310)}`;

    /* Lower arc back to subsolar point */
    lower.forEach(([x, y]) => path += ` L ${x},${y}`);
    path += ' Z';

    $('shue-path')?.setAttribute('d', path);
  }

  /* ── 5. Tail-cap line and inner boundary ────────────────────────────── */
  const tc = $('shue-tailcap');
  if (tc) {
    tc.setAttribute('x1', xtSvgX); tc.setAttribute('x2', xtSvgX);
    tc.setAttribute('y1', '20');    tc.setAttribute('y2', '300');
  }
  const tl = $('shue-tailcap-lbl');
  if (tl) { tl.setAttribute('x', xtSvgX + 3); tl.textContent = 'Xtail=' + S.xtail; }

  /* Inner boundary circle */
  const ish = $('inner-shue');
  if (ish) ish.setAttribute('r', S.shueRinner * SC);
  setText('inner-shue-lbl', `R_in=${S.shueRinner} RE`);

  /* ── 6. Annotation arrows ───────────────────────────────────────────── */
  /* r₀ arrow: Earth centre → subsolar point */
  const r0svgX = cl(gx(r0), 10, 385);
  const r0line = $('shue-r0-line');
  if (r0line) { r0line.setAttribute('x2', r0svgX); r0line.setAttribute('y2', CY); }
  const r0lbl = $('shue-r0-lbl');
  if (r0lbl) { r0lbl.setAttribute('x', cl(gx(r0 / 2), 10, 370)); r0lbl.textContent = `r₀=${r0.toFixed(1)}`; }

  /* Flank arrow: Earth → terminator (X=0, Z=R_flank) */
  if (isFinite(rFlank)) {
    const flkSvgY = cl(gz(Math.min(rFlank, 28)), 10, 300);
    const flkLine = $('shue-flank-line');
    if (flkLine) {
      flkLine.setAttribute('x1', CX); flkLine.setAttribute('y1', CY);
      flkLine.setAttribute('x2', CX); flkLine.setAttribute('y2', flkSvgY);
    }
    const flkLbl = $('shue-flank-lbl');
    if (flkLbl) {
      flkLbl.setAttribute('y', ((flkSvgY + CY) / 2).toFixed(1));
      flkLbl.textContent = `Rflk=${rFlank.toFixed(1)}`;
    }
  }

  /* ── 7. Dynamic SVG text readouts ───────────────────────────────────── */
  setText('shue-svg-r0',    `r₀=${r0.toFixed(2)} RE`);
  setText('shue-svg-alpha', `α=${alpha.toFixed(3)}`);
  setText('shue-svg-dst',   `Dst=${S.dst < 0 ? '−' + Math.abs(S.dst) : S.dst} nT`);
  setText('shue-svg-pdyn',  `Pdyn=${S.pdyn} nPa`);

  /* ── 8. Validation checks ───────────────────────────────────────────── */
  const vi = (id, ok, okT, failT) => {
    const e = $(id);
    if (e) e.innerHTML = ok
      ? `<span class="bv-ok">${okT}</span>`
      : `<span class="bv-warn">${failT}</span>`;
  };
  vi('sv-r0',    r0 > 5 && r0 < 13,          `✓ r₀=${r0.toFixed(2)} R<sub>E</sub> (storm-time)`,
                                               `⚠ r₀=${r0.toFixed(2)} — outside 5–13 R<sub>E</sub>`);
  vi('sv-alpha', alpha > 0.4 && alpha < 0.8,  `✓ α=${alpha.toFixed(3)} (normal range)`,
                                               `⚠ α=${alpha.toFixed(3)} — outside 0.40–0.80`);
  vi('sv-tail',  S.xtail < -20,               `✓ Tail cap at ${S.xtail} R<sub>E</sub>`,
                                               `⚠ X_tail should be < −20 R<sub>E</sub>`);

  /* ── 9. Keyword preview strips ──────────────────────────────────────── */
  const isM = S.shueMode === 'manual';
  setText('kw-shue-r0',     isM ? r0.toFixed(2)    : 'AUTO');
  setText('kw-shue-alpha',  isM ? alpha.toFixed(3)  : 'AUTO');
  setText('kw-xtail',       S.xtail.toFixed(1));
  setText('kw-shue-rinner', S.shueRinner.toFixed(1));
}


/* ═══════════════════════════════════════════════════════════════════════════
   §2c  SVG GRID — background coordinate grid (drawn once on init)
   ═══════════════════════════════════════════════════════════════════════════ */

/**
 * Draw the background GSM coordinate grid inside an SVG <g> element.
 *
 * Creates vertical lines (X_GSM) and horizontal lines (Z_GSM) at 5 RE intervals.
 * The X=0 and Z=0 axes are drawn with solid lines; others are dashed.
 * Numeric labels appear every 20 RE.
 *
 * Called once during init() for both 'shue-grid' and 'box-grid' groups.
 * After this call, the grid is static — it never needs to be redrawn.
 *
 * @param {string} svgId — ID of the <g> element to populate (e.g. 'shue-grid')
 */
function drawSvgGrid(svgId) {
  const g = document.getElementById(svgId);
  if (!g) return;

  let html = '';

  /* ── Vertical grid lines (X_GSM, −60 to +20 RE) ────────────────────── */
  for (let x = -60; x <= 20; x += 5) {
    const px = cl(gx(x), 5, 390);
    const isAxis = x === 0;
    html += `<line x1="${px}" y1="4" x2="${px}" y2="316" `
          + `stroke="${isAxis ? '#1e3a5a' : '#0c1e38'}" `
          + `stroke-width="${isAxis ? 1 : 0.5}" `
          + `${isAxis ? '' : 'stroke-dasharray="3,5"'}/>`;

    /* Labels every 20 RE (skip origin) */
    if (x % 20 === 0 && x !== 0) {
      html += `<text x="${px - 8}" y="${CY + 18}" fill="#1a3050" `
            + `font-family="IBM Plex Mono" font-size="8">${x}RE</text>`;
    }
  }

  /* ── Horizontal grid lines (Z_GSM, −35 to +35 RE) ──────────────────── */
  for (let z = -35; z <= 35; z += 5) {
    const py = cl(gz(z), 5, 310);
    const isAxis = z === 0;
    html += `<line x1="4" y1="${py}" x2="396" y2="${py}" `
          + `stroke="${isAxis ? '#1e3a5a' : '#0c1e38'}" `
          + `stroke-width="${isAxis ? 1 : 0.5}" `
          + `${isAxis ? '' : 'stroke-dasharray="3,5"'}/>`;

    if (z % 20 === 0 && z !== 0) {
      html += `<text x="${CX + 3}" y="${py + 3}" fill="#1a3050" `
            + `font-family="IBM Plex Mono" font-size="8">${z}RE</text>`;
    }
  }

  g.innerHTML = html;
}


/* ═══════════════════════════════════════════════════════════════════════════
   §3  COMPATIBILITY SHIMS — robust legacy-HTML support
   ═══════════════════════════════════════════════════════════════════════════

   The multi-file site (index.html) loads panel_boundary.html, which
   historically used different onclick handler names than the standalone
   AMPS_Interface.html.  These IIFE shims ensure ALL HTML variants work.

   Legacy:  setBoundary('box'|'shue')          → bndSet('BOX'|'SHUE')
   Legacy:  setShueMode(this,'auto'|'manual')  → shueMode('auto'|'manual')

   DO NOT REMOVE unless all HTML files are updated to use only bndSet/shueMode.
   ─────────────────────────────────────────────────────────────────────────── */
(function() {
  const G = (typeof window !== 'undefined') ? window : globalThis;

  if (typeof G.setBoundary !== 'function') {
    G.setBoundary = function(which) {
      const w = String(which || '').toLowerCase();
      if (w === 'box' || w === 'rect' || w === 'rectangular') return bndSet('BOX');
      if (w === 'shue' || w === 'mp' || w === 'magnetopause')  return bndSet('SHUE');
      return bndSet(S.boundary || 'SHUE');
    };
  }

  if (typeof G.setShueMode !== 'function') {
    G.setShueMode = function(_btn, mode) {
      return shueMode(String(mode || 'auto').toLowerCase());
    };
  }
})();
