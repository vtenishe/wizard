/*
=====================================================================
FILE: js/08-review.js
INTENT:
  JavaScript logic for the AMPS web wizard (static site). This module
  implements a focused part of the UI: state updates, model selection,
  preview rendering, or navigation.

METHODS / DESIGN:
  - Reads/writes the shared state object `S` (defined in js/01-state.js).
  - Uses direct DOM manipulation (no framework) for portability.
  - Functions are intentionally small and side-effectful: they update `S`
    and then update the DOM so the UI always reflects the current state.

IMPLEMENTATION NOTES:
  - Prefer pure helpers for formatting and mapping, but keep UI updates
    local so itâ€™s clear which elements are affected.
  - Avoid introducing new global names unless necessary; when you do,
    document them here and in-line.
  - Keep behavior consistent between modular (index.html + js/*.js) and
    standalone (AMPS_Interface.html) entrypoints.

LAST UPDATED: 2026-02-21
=====================================================================
*/
/* =============================================================================
   FILE:    js/08-review.js
   PROJECT: AMPS CCMC Submission Interface  v3
   PURPOSE: Step 11 â€” Review, AMPS_PARAM.in file builder, run manifest,
            client-side validation, job submission, and sidebar summary.

   AMPS_PARAM.in FILE BUILDER  (buildReview)
     Generates a complete, commented AMPS_PARAM.in file from the current
     state object S.  Output is rendered into the #review-param element as
     colour-coded HTML using .kw-strip span classes, and can be:
       Â· Copied to clipboard  (copyParam)
       Â· Downloaded as a .in text file  (downloadParam)

     The param-file structure mirrors the AMPS v2025 input specification:
       #RUN_ID, #CALCULATION_MODE, #CUTOFF_RIGIDITY (conditional),
       #PARTICLE, #FIELD_MODEL + model-specific block,
       #DOMAIN_BOUNDARY, #ELECTRIC_FIELD, #TEMPORAL, #SPECTRUM, #OUTPUT

     CALCULATION_MODE SECTION (added 2026-02-21):
       Emitted unconditionally.  Contains:
         CALC_TARGET        â€” from S.calcQuantity
         FIELD_EVAL_METHOD  â€” from S.fieldMethod
         GRID_NX/NY/NZ + extents â€” only when fieldMethod === 'GRID_3D'

     CUTOFF_RIGIDITY SECTION (added 2026-02-21):
       Emitted only when S.calcQuantity is not 'FLUX'.  Contains:
         CUTOFF_EMIN, CUTOFF_EMAX, CUTOFF_MAX_PARTICLES, CUTOFF_NENERGY

   RUN MANIFEST  (buildManifest)
     Lists all expected output files so users know what to retrieve after
     the run completes on the CCMC cluster.  Depends on output mode and
     energy bin count.

   VALIDATION  (buildValidation)
     Scans S for potentially dangerous or unusual configurations and
     returns an array of {level, text} warning objects:
       'ok'   â€” configuration looks standard
       'warn' â€” unusual but may be intentional (shown in amber)
       'error'â€” configuration will cause AMPS to fail (shown in red)

   SIDEBAR SUMMARY  (updateSidebar)
     Lightweight function called after every user interaction.
     Writes a one-line summary of each wizard step into the fixed
     right-hand sidebar for at-a-glance status.
     Also updates the progress bar fill (# done steps / 9).

   PUBLIC API
     buildReview()     â€” render full AMPS_PARAM.in preview into #review-param
     copyParam()       â€” copy plain-text param file to clipboard
     downloadParam()   â€” trigger browser download of amps_param.in
     buildManifest()   â€” return HTML string listing output files
     buildValidation() â€” return array of validation messages
     finalSubmit()     â€” submit the run to CCMC (triggers confirm dialog)
     updateSidebar()   â€” refresh the right-hand sidebar summary
     openHelpModal()   â€” show the help overlay

   DEPENDS ON: 01-state.js (S, $, set),
               03-bgfield.js (S.fieldModel),
               04-boundary.js (S.boundaryType, shueCalc),
               05-efield.js (S.eFieldCoro, S.eFieldConvModel)
=============================================================================*/

function buildReview(){
  const {r0,alpha}=getShue();
  const isM=S.shueMode==='manual';
  const f=(v,d)=>Number(v).toFixed(d);

  /* â”€â”€ Assemble the AMPS_PARAM.in text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   *  The array elements are joined with '\n'.  Conditional blocks use
   *  ternary expressions to emit model-specific sub-sections or empty
   *  strings based on the current state. */
  const txt=[
`! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
! AMPS_PARAM.in â€” generated by CCMC Runs-on-Request interface
! Run: ${S.runName||'unnamed'}
! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#RUN_INFO
RUN_ID                 ${S.runName||'unnamed'}
PI_NAME                ${S.piName||'Unknown'}
PI_EMAIL               ${S.piEmail||'unknown@unknown.edu'}
SCIENCE_GOAL           ${$('science-goal')?.value||'custom'}

! â”€â”€ Calculation mode (Step 2) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
! CALC_TARGET: what the run computes (cutoff rigidity, flux, or both).
! FIELD_EVAL_METHOD: how B/E are evaluated (analytic vs grid interpolation).
! GRID_* keywords are only emitted when FIELD_EVAL_METHOD = GRID_3D.
#CALCULATION_MODE
CALC_TARGET            ${S.calcQuantity}
FIELD_EVAL_METHOD      ${S.fieldMethod}`,

/* â”€â”€ Conditional: 3-D grid dimensions and spatial extent â”€â”€
 *  Only emitted when FIELD_EVAL_METHOD = GRID_3D.
 *  The grid is a regular Cartesian mesh in GSM coordinates. */
S.fieldMethod==='GRID_3D'?`GRID_NX                ${S.gridNx}
GRID_NY                ${S.gridNy}
GRID_NZ                ${S.gridNz}
GRID_XMIN              ${f(S.gridXmin,1)}         ! RE GSM
GRID_XMAX              ${f(S.gridXmax,1)}
GRID_YMIN              ${f(S.gridYmin,1)}
GRID_YMAX              ${f(S.gridYmax,1)}
GRID_ZMIN              ${f(S.gridZmin,1)}
GRID_ZMAX              ${f(S.gridZmax,1)}`:'',

/* â”€â”€ Conditional: cutoff rigidity parameters â”€â”€
 *  Emitted when CALC_TARGET is CUTOFF_RIGIDITY or BOTH.
 *  Omitted when CALC_TARGET is FLUX (cutoff not computed). */
S.calcQuantity!=='FLUX'?`
! â”€â”€ Cutoff rigidity scan (Step 2, Section C) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
! Energy range and particle budget for backward-tracing cutoff search.
#CUTOFF_RIGIDITY
CUTOFF_EMIN            ${f(S.cutoffEmin,1)}          ! MeV/n
CUTOFF_EMAX            ${f(S.cutoffEmax,1)}       ! MeV/n
CUTOFF_MAX_PARTICLES   ${S.cutoffMaxParticles}              ! per injection point
CUTOFF_NENERGY         ${S.cutoffNenergy}               ! log-spaced energy bins`:'',
`
#PARTICLE_SPECIES
SPECIES                ${S.species.toUpperCase()}
CHARGE                 ${S.charge}               ! elementary charge
MASS_AMU               ${S.mass}           ! atomic mass units

#BACKGROUND_FIELD
FIELD_MODEL            ${S.fieldModel}
TS05_DST               ${f(S.dst,1)}         ! nT ring current index
TS05_PDYN              ${f(S.pdyn,2)}          ! nPa dynamic pressure
TS05_BZ                ${f(S.bz,2)}         ! nT IMF Bz GSM
TS05_VX                ${f(S.vx,1)}       ! km/s solar wind Vx
TS05_NSW               ${f(S.nsw,2)}         ! cm-3 proton density
TS05_BY                ${f(S.by,2)}          ! nT IMF By
TS05_BX                ${f(S.bx,2)}          ! nT IMF Bx
EPOCH                  ${S.epoch}  ! UTC snapshot

#DOMAIN_BOUNDARY
BOUNDARY_TYPE          ${S.boundaryType}${S.boundaryType==='SHUE'?'  ! Shue et al. 1998 magnetopause':'  ! rectangular box in GSM'}`,
S.boundaryType==='BOX'?`DOMAIN_X_MAX           ${f(S.boxXmax,1)}         ! RE dayside
DOMAIN_X_MIN           ${f(S.boxXmin,1)}        ! RE nightside
DOMAIN_Y_MAX           ${f(S.boxYmax,1)}         ! RE dusk
DOMAIN_Y_MIN           ${f(S.boxYmin,1)}        ! RE dawn
DOMAIN_Z_MAX           ${f(S.boxZmax,1)}         ! RE north
DOMAIN_Z_MIN           ${f(S.boxZmin,1)}        ! RE south
R_INNER                ${f(S.boxRinner,1)}           ! RE inner loss sphere`:
`SHUE_R0                ${isM?f(r0,2):'AUTO'}            ! RE; AUTO = from TS05 Bz,Pdyn
SHUE_ALPHA             ${isM?f(alpha,3):'AUTO'}         ! flaring; AUTO = from TS05
DOMAIN_X_TAIL          ${f(S.xtail,1)}        ! RE nightside cap
R_INNER                ${f(S.shueRinner,1)}           ! RE inner loss sphere`,
`
#TEMPORAL
TEMPORAL_MODE          ${S.tempMode}`,
S.tempMode!=='STEADY_STATE'?`EVENT_START            ${S.eventStart}   ! UTC
EVENT_END              ${S.eventEnd}   ! UTC
FIELD_UPDATE_DT        ${S.fieldDt}                ! min
INJECT_DT              ${S.injectDt}               ! min
TS_INPUT_MODE          ${S.tsSource==='omni'?'OMNIWEB':S.tsSource==='file'?'FILE':'SCALAR'}`:
`EPOCH                  ${S.epoch}`,
`
#SPECTRUM
SPECTRUM_TYPE          ${S.specType}`,
S.specType==='POWER_LAW'?`SPEC_J0                ${S.specJ0.toExponential(2)}   ! p/cm2/s/sr/(MeV/n)
SPEC_GAMMA             ${f(S.specGamma,2)}         ! spectral index
SPEC_E0                ${f(S.specE0,1)}          ! MeV/n pivot`:
S.specType==='POWER_LAW_CUTOFF'?`SPEC_J0                ${S.specJ0.toExponential(2)}   ! p/cm2/s/sr/(MeV/n)
SPEC_GAMMA             ${f(S.specGamma,2)}         ! spectral index
SPEC_E0                ${f(S.specE0,1)}          ! MeV/n pivot
SPEC_EC                ${f(S.specEc,1)}        ! MeV/n exponential cutoff`:
S.specType==='LIS_FORCE_FIELD'?`SPEC_LIS_J0            ${S.specLisJ0.toExponential(2)}   ! p/cm2/s/sr/(MeV/n) LIS normalization
SPEC_LIS_GAMMA         ${f(S.specLisGamma,2)}         ! LIS spectral index
SPEC_E0                ${f($('lis-e0')?.value||S.specE0,1)}          ! MeV/n pivot
SPEC_PHI               ${f(S.specPhi,0)}          ! MV solar modulation potential`:
S.specType==='BAND'?`SPEC_J0                ${S.specJ0.toExponential(2)}   ! p/cm2/s/sr/(MeV/n)
SPEC_GAMMA1            ${f(parseFloat($('band-gamma1')?.value)||3.5,2)}         ! low-energy index
SPEC_GAMMA2            ${f(parseFloat($('band-gamma2')?.value)||1.5,2)}         ! high-energy index
SPEC_E0                ${f(parseFloat($('band-e0')?.value)||10,1)}          ! MeV/n break energy`:
S.specType==='TABLE'?`SPEC_TABLE_FILE        sep_spectrum_H+.txt  ! user-provided E vs J table`:``,
`SPEC_EMIN              ${f(S.specEmin,1)}          ! MeV/n
SPEC_EMAX              ${f(S.specEmax,1)}       ! MeV/n

#OUTPUT_DOMAIN
OUTPUT_MODE            ${S.outputMode}
FLUX_DT                ${f(S.fluxDt,1)}           ! min output cadence

#OUTPUT_OPTIONS
FLUX_TYPE              ${S.fluxType}
OUTPUT_CUTOFF          ${$('output-cutoff')?.checked?'T':'F'}                    ! cutoff rigidity maps
OUTPUT_PITCH           ${$('output-pitch')?.checked?'T':'F'}                    ! pitch angle distributions
OUTPUT_FORMAT          ${$('output-format')?.value||S.outputFormat}
OUTPUT_COORDS          ${$('output-coords')?.value||S.outputCoords}
ENERGY_BINS            ${S.energyBins.join(' ')}   ! MeV/n

#NUMERICAL
N_PARTICLES            10000              ! test particles per injection
MAX_BOUNCE             500                ! max mirror reflections
DT_TRACE               1.0               ! s integration step
PITCH_ISOTROPIC        T                 ! isotropic injection

#END`
].join('\n');

  const el=$('review-param'); if(!el) return;
  el.innerHTML=txt
    .replace(/^(#\w[\w_]*)/gm,'<span class="r-section">$1</span>')
    .replace(/^(! .+)/gm,'<span class="r-comment">$1</span>')
    .replace(/(AUTO)/g,'<span class="r-auto">AUTO</span>');

  buildManifest(); buildValidation();
  return txt;
}

function copyParam(){ navigator.clipboard.writeText(buildReview().replace(/<[^>]+>/g,'')).then(()=>{ const b=$('copy-param'); if(b){b.textContent='âœ“ Copied';setTimeout(()=>{b.textContent='ğŸ“‹ Copy';},2000);} }); }
function downloadParam(){
  const txt=(buildReview()||'').replace(/<[^>]+>/g,'');
  const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([txt],{type:'text/plain'}));
  a.download='AMPS_PARAM.in'; a.click();
}

function buildManifest(){
  const tb=$('manifest-tbody'); if(!tb) return;
  const files=[
    {name:'AMPS_PARAM.in',      role:'Main configuration',            req:true, auto:true,  ok:true},
    {name:'AMPS_MANIFEST.json', role:'Run metadata (auto-generated)', req:true, auto:true,  ok:true},
    {name:'trajectory.txt',     role:'Spacecraft trajectory (Mode B)',req:S.outputMode==='TRAJECTORY', auto:false, ok:S.trajLoaded},
    {name:'ts05_driving.txt',   role:'TS05 time-series drivers',      req:S.tempMode==='TIME_SERIES'&&S.tsSource==='file', auto:S.tsSource==='omni', ok:true},
    {name:'sep_spectrum_H+.txt',role:'Spectrum table (if TABLE mode)',req:S.specType==='TABLE', auto:false, ok:S.specType!=='TABLE'},
  ];
  tb.innerHTML=files.filter(f=>f.req||f.auto).map(f=>`
    <tr>
      <td style="font-family:var(--font-mono);color:var(--text)">${f.name}</td>
      <td style="color:var(--text-dim)">${f.role}</td>
      <td style="color:${f.req?'var(--text)':'var(--text-muted)'}">${f.req?'Required':'Optional'}</td>
      <td style="color:${f.auto?'var(--green)':'var(--text-dim)'}">${f.auto?'Auto-generated':'User upload'}</td>
      <td class="${f.ok?'vt-pass':'vt-fail'}">${f.ok?'âœ“ READY':'âœ— MISSING'}</td>
    </tr>`).join('');
}

function buildValidation(){
  const {r0,alpha}=getShue();

  /* â”€â”€ Validation checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   *  Each check is an object {l: label, ok: boolean, warn?: boolean}.
   *    ok=true  â†’ PASS (green)
   *    ok=false, warn=false â†’ FAIL / fatal (red) â€” blocks submission
   *    ok=false, warn=true  â†’ WARNING (amber)    â€” allows submission
   *
   *  New checks added for Step 2 (Calculation Mode):
   *    - Calc target must be a recognized keyword.
   *    - Field method must be a recognized keyword.
   *    - Cutoff Emin must be strictly less than Emax (skipped if FLUX).
   *    - Cutoff max particles must be at least 50 (skipped if FLUX).
   *    - Gridless mode must not be paired with an MHD field model
   *      (BATSRUS/GAMERA require grid interpolation).
   * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const chks=[
    /* â”€â”€ Step 1: Run info â”€â”€ */
    {l:'Run name set',           ok:!!(S.runName?.trim())},
    {l:'PI email valid',         ok:/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test($('pi-email')?.value||'')},

    /* â”€â”€ Step 2: Calculation mode â”€â”€
     *  These ensure the two top-level choices are valid and mutually
     *  consistent.  The gridless+Tsyganenko check prevents the user
     *  from submitting an impossible configuration (MHD model needs
     *  a grid, but gridless was selected). */
    {l:'Calc target selected',   ok:['CUTOFF_RIGIDITY','FLUX','BOTH'].includes(S.calcQuantity)},
    {l:'Field method selected',  ok:['GRIDLESS','GRID_3D'].includes(S.fieldMethod)},
    {l:'Cutoff Emin < Emax',     ok:S.calcQuantity==='FLUX'||(S.cutoffEmin<S.cutoffEmax)},
    {l:'Cutoff particles â‰¥ 50',  ok:S.calcQuantity==='FLUX'||(S.cutoffMaxParticles>=50)},
    {l:'Gridless â†’ Tsyganenko only', ok:S.fieldMethod!=='GRIDLESS'||!['BATSRUS','GAMERA'].includes(S.fieldModel)},

    /* â”€â”€ Step 3â€“5: Field, boundary â”€â”€ */
    {l:'Dst in TS05 range',      ok:S.dst>=-600&&S.dst<=50},
    {l:'Pdyn > 0.1 nPa',         ok:S.pdyn>0.1},
    {l:'Domain boundary set',    ok:['BOX','SHUE'].includes(S.boundaryType)},
    {l:'Shue râ‚€ plausible (5â€“13 RE)', ok:S.boundaryType!=='SHUE'||( r0>5&&r0<13)},

    /* â”€â”€ Step 7â€“10: Temporal, spectrum, output â”€â”€ */
    {l:'Inject Î”t â‰¥ Field Update', ok:S.tempMode==='STEADY_STATE'||S.injectDt>=S.fieldDt},
    {l:'Energy bins defined',    ok:S.energyBins.length>0},
    {l:'Spectrum type selected', ok:['POWER_LAW','POWER_LAW_CUTOFF','LIS_FORCE_FIELD','BAND','TABLE'].includes(S.specType)},
    {l:'Output mode selected',   ok:['POINTS','TRAJECTORY','SHELLS'].includes(S.outputMode)},
    {l:'Trajectory file loaded', ok:S.outputMode!=='TRAJECTORY'||S.trajLoaded, warn:true},
  ];
  const pass=chks.filter(c=>c.ok).length;
  const fail=chks.filter(c=>!c.ok&&!c.warn).length;
  const warn=chks.filter(c=>!c.ok&&c.warn).length;
  const rs=$('review-summary');
  if(rs) rs.innerHTML=`<span class="v-ok">âœ“ ${pass} passed</span> Â· <span class="v-warn">âš  ${warn} warning</span> Â· <span class="v-err">âœ— ${fail} fatal</span>`;
  const rc=$('review-checks'); if(rc){ rc.innerHTML='';
    chks.forEach(c=>{ const d=document.createElement('div');
      d.className='review-item '+(c.ok?'ri-ok':c.warn?'ri-warn':'');
      d.innerHTML=`<div class="ri-label">${c.l}</div><div class="ri-val">${c.ok?'âœ“ PASS':c.warn?'âš  WARN':'âœ— FAIL'}</div>`;
      rc.appendChild(d); }); }
  const sb=$('submit-btn-final'); if(sb) sb.disabled=fail>0;
}

function finalSubmit(){
  const m=$('submit-modal'); if(m) m.style.display='flex';
}

/* â”€â”€ 6. SIDEBAR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  updateSidebar() writes a one-line summary of each wizard step into
 *  the fixed right-hand sidebar.  It is called after every user
 *  interaction that changes state (input change, card click, etc.).
 *
 *  The local `set` function is a sidebar-scoped wrapper around the
 *  global `set()` in 01-state.js, but adds a 'sb-v' class prefix
 *  for sidebar-specific CSS styling (green/orange/red badges).
 *
 *  Progress bar: the bar fill is (done steps / 10) Ã— 100%.
 *  There are 10 completable steps (1â€“10); step 11 is Review and is
 *  not itself "completable" â€” it's the terminal state.
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function updateSidebar(){
  const set=(id,v,cls)=>{ const e=$(id); if(e){e.textContent=v;if(cls)e.className='sb-v '+cls;} };

  /* â”€â”€ Step 1: Run name â”€â”€ */
  set('sb-run-name', S.runName||'(not set)', S.runName?'':'o');

  /* â”€â”€ Step 2: Calculation mode (added 2026-02-21) â”€â”€
   *  Two sidebar rows: 'Calc target' and 'Field method'.
   *  prettyCalcTarget maps the raw state keyword to a human-readable
   *  label for the sidebar badge. */
  const prettyCalcTarget = {
    CUTOFF_RIGIDITY: 'CUTOFF RIGIDITY',
    FLUX: 'PARTICLE FLUX',
    BOTH: 'CUTOFF + FLUX'
  };
  set('sb-calc-target', prettyCalcTarget[S.calcQuantity] || S.calcQuantity, 'g');
  set('sb-field-method', S.fieldMethod === 'GRIDLESS' ? 'Gridless (analytic)' : '3-D Grid', S.fieldMethod === 'GRIDLESS' ? 'g' : '');

  /* â”€â”€ Step 3: Species â”€â”€ */
  set('sb-species',  S.species==='proton'?'Hâº Proton':S.species==='helium'?'HeÂ²âº':S.species==='electron'?'eâ»':S.species,'g');

  /* â”€â”€ Step 4: Background B-field â”€â”€ */
  // Sidebar must reflect the actual user-selected background B-field model.
  // (Previously this was hard-coded to 'TS05', which made the review summary incorrect.)
  const prettyField = {
    TS05: 'TS05 (Tsyganenko 2005)',
    T04S: 'T04s (Tsyganenko 2004 storm)',
    T96:  'T96 (Tsyganenko 1996)',
    T95M: 'T95m (modified Tsyganenko 1995)',
    T15:  'T15 (Tsyganenko 2015)',
    BATSRUS: 'BATSRUS (MHD input)',
    GAMERA:  'GAMERA (MHD input)'
  };
  set('sb-field-model', prettyField[S.fieldModel] || S.fieldModel || 'â€”', 'g');

  /* â”€â”€ Step 5: Boundary â”€â”€ */
  set('sb-boundary', S.boundaryType==='SHUE'?'Shue 1998':'Box (GSM)','g');

  /* â”€â”€ Step 6: E-field â€” disabled in gridless mode (added 2026-02-21) â”€â”€
   *  When S.fieldMethod is 'GRIDLESS', the E-field is physically excluded
   *  from the simulation.  The sidebar shows "N/A (gridless)" in orange
   *  to indicate that this step was intentionally skipped.
   *  In GRID_3D mode, the sidebar shows the active E-field components
   *  (e.g. "Coro+VS(Kp)" or "Coro+Weimer"). */
  if (S.fieldMethod === 'GRIDLESS') {
    set('sb-efield', 'N/A (gridless)', 'o');
  } else {
    const efParts = [];
    if (S.eFieldCoro) efParts.push('Coro');
    if (S.eFieldConvModel === 'VOLLAND_STERN') efParts.push('VS(Kp)');
    else if (S.eFieldConvModel === 'WEIMER') efParts.push('Weimer');
    set('sb-efield', efParts.length ? efParts.join('+') : 'None', efParts.length ? 'g' : 'o');
  }

  /* â”€â”€ Steps 7â€“10: Temporal, spectrum, output â”€â”€ */
  set('sb-temporal', S.tempMode.replace('_',' '),'');
  const prettySpec = {
    POWER_LAW: 'POWER LAW',
    POWER_LAW_CUTOFF: 'PL + EXP CUTOFF',
    LIS_FORCE_FIELD: 'LIS + FORCE-FIELD',
    BAND: 'BAND FUNCTION',
    TABLE: 'TABLE FILE'
  };
  set('sb-spec-type', prettySpec[S.specType] || S.specType.replace('_',' '),'');
  set('sb-output-mode', S.outputMode.replace('_',' '),'g');

  /* â”€â”€ Progress bar â”€â”€
   *  Denominator is 10: steps 1â€“10 are completable; step 11 (Review)
   *  is the terminal state and is not included in the progress count.
   *  (Changed from 9 to 10 when Step 2 "Calc Mode" was inserted.) */
  const pct=Math.round((S.done.size/10)*100);
  const pf=$('progress-fill'); if(pf) pf.style.width=pct+'%';
  const pp=$('progress-pct'); if(pp) pp.textContent=pct+'%';
}

/* â”€â”€ 7. HELP MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function openHelpModal(){ const m=$('help-modal'); if(m) m.style.display='flex'; }
